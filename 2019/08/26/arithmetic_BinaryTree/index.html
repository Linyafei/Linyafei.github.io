<!DOCTYPE html>
<html id="layout_html">

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">


  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!--Description-->
  
    <meta name="description" content="个人博客用于记录自己学习iOS，Flutter，Java，Dart的日常积累">
  

  <!--Author-->
  
    <meta name="author" content="LYF">
  

  <!--Open Graph Title-->
  
    <meta property="og:title" content="二叉树"/>
  

  <!--Open Graph Description-->
  
    <meta property="og:description" content="个人博客用于记录自己学习iOS，Flutter，Java，Dart的日常积累" />
  

  <!--Open Graph Site Name-->
  <meta property="og:site_name" content="linyafei&#39;s blog"/>

  <!--Type page-->
  
    <meta property="og:type" content="article" />
  

  <!--Page Cover-->
  

  <meta name="twitter:card" content="summary" />
  

  <!-- Title -->
  
  <title>二叉树 - linyafei&#39;s blog</title>

  <!-- Tachyons Core CSS -->
  <link rel="stylesheet" href="https://unpkg.com/tachyons/css/tachyons.min.css">

  <!-- Custom Fonts -->
  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">

  <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]>
  <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
  <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
  <![endif]-->

  
<link rel="stylesheet" href="/css/style.css">




<meta name="generator" content="Hexo 5.0.0"></head>


<body id="layout_body">
    <header id="layout_header">
        
<div id="header_background_image">
    <div id="header_nav_list">
      
        <a id="header_nav_link"
        href="/">
            
                主页
            
        </a>
      
        <a id="header_nav_link"
        href="/archives">
            
                归档
            
        </a>
      
        <a id="header_nav_link"
        href="/categories">
            
                分类
            
        </a>
      
        <a id="header_nav_link"
        href="/tags">
            
                标签
            
        </a>
      
        <a id="header_nav_link"
        href="/about.html">
            
                关于
            
        </a>
      
    </div>

    <div id="header_title">
        <span>林亚飞的博客</span>
    </div>
    <div id="header_subtitle">
         <span>记录自己前进的每一步足迹</span>
    </div>

</div>

    </header>

    <main id="layout_main">
        
<article id="post_background">
  <div id="post_title">二叉树</div>
  <div id="post_time">2019-08-26</div>

  <div id="post_content"> <p>import java.util.Queue;<br>import java.util.LinkedList;<br>import java.util.Stack;<br>import java.util.ArrayList;<br>import java.util.List;<br>import java.lang.Comparable;</p>
<p>public class MyBinaryTree {<br>    public static void main(String[] args) {<br>        TestTreeClass ttc = new TestTreeClass();<br>//        ttc.testBinaryTreeClass();<br>//        ttc.testBinaryTree();<br>        int[] tmpArr= {3,2,1,4,5,6,7,16,15,14,13,12,11,10,8,9};<br>        ttc.testAVLTree(tmpArr);<br>    }<br>}<br>class TestTreeClass {<br>    public void testBinaryTreeClass() {<br>        BinaryTreeClass btc = new BinaryTreeClass();<br>        btc.insert(5);<br>        btc.insert(3);<br>        btc.insert(4);<br>        btc.insert(1);<br>        btc.insert(2);<br>        btc.insert(7);<br>        btc.insert(6);<br>        btc.insert(8);<br>//        btc.prevTraversal(btc.rootNode);<br>//        System.out.println(“==size==” + btc.size + “===========”);<br>//        btc.midTraversal(btc.rootNode);<br>//        System.out.println(“==size==========” + btc.size + “==”);<br>//        btc.reatTraversal(btc.rootNode);<br>//        System.out.println(“==size==” + btc.size + “===========”);<br>        System.out.println(“==delete==” + btc.delete(8) + “==”);<br>        btc.midTraversal(btc.rootNode);<br>        System.out.println(“==size==========” + btc.size + “==”);<br>        System.out.println(“==find==” + btc.find(3) + “==”);<br>    }<br>    public void testBinaryTree() {<br>        BinaryTree mBinaryTree = new BinaryTree();<br>        TreeNode root = mBinaryTree.createTree();<br>//<br>        System.out.print(“前序遍历-递归实现:”);<br>        mBinaryTree.preTraversal(root);<br>        System.out.print(“\n中序遍历-递归实现:”);<br>        mBinaryTree.traversal(root);<br>        System.out.print(“\n后序遍历-递归实现:”);<br>        mBinaryTree.postTraversal(root);<br>        System.out.println();<br>//<br>        System.out.println(“\n前序遍历-迭代实现:”);<br>        mBinaryTree.preTraversalIteration(root);<br>        System.out.print(“\n中序遍历-迭代实现:”);<br>        mBinaryTree.TraversalIteration(root);<br>        System.out.print(“\n后序遍历-迭代实现:”);<br>        mBinaryTree.postTraversalIteration(root);<br>//        System.out.println();<br>//        System.out.println(“\n层序遍历:”);<br>//        mBinaryTree.levelTraversal(root);<br>    }<br>    public void testAVLTree(int[] arr) {<br>        int i;<br>        AVLTree<Integer> tree = new AVLTree<Integer>();<br>        System.out.printf(“== 依次添加: “);<br>        for(i=0; i&lt;arr.length; i++) {<br>            System.out.printf(“%d “, arr[i]);<br>            tree.insert(arr[i]);<br>        }<br>        System.out.printf(“\n== 前序遍历: “);<br>        tree.preOrder();<br>//<br>        System.out.printf(“\n== 中序遍历: “);<br>        tree.inOrder();<br>//<br>        System.out.printf(“\n== 后序遍历: “);<br>        tree.postOrder();<br>        System.out.printf(“\n”);<br>//<br>        System.out.printf(“== 高度: %d\n”, tree.height());<br>        System.out.printf(“== 最小值: %d\n”, tree.minimum());<br>        System.out.printf(“== 最大值: %d\n”, tree.maximum());<br>        System.out.printf(“== 树的详细信息: \n”);<br>        tree.print();<br>//<br>        i = 8;<br>        System.out.printf(“\n== 删除根节点: %d”, i);<br>        tree.remove(i);<br>//<br>        System.out.printf(“\n== 高度: %d”, tree.height());<br>        System.out.printf(“\n== 中序遍历: “);<br>        tree.inOrder();<br>        System.out.printf(“\n== 树的详细信息: \n”);<br>        tree.print();<br>        // 销毁二叉树<br>        tree.destroy();<br>    }<br>}<br>class AVLTree&lt;T extends Comparable<T>&gt; {<br>    // AVL树的节点(内部类)<br>    class AVLTreeNode&lt;T extends Comparable<T>&gt; {<br>        T key;                // 关键字(键值)<br>        int height;         // 高度<br>        AVLTreeNode<T> left;    // 左孩子<br>        AVLTreeNode<T> right;    // 右孩子<br>        public AVLTreeNode(T key, AVLTreeNode<T> left, AVLTreeNode<T> right) {<br>            this.key = key;<br>            this.left = left;<br>            this.right = right;<br>            this.height = 0;<br>        }<br>    }<br>    private AVLTreeNode<T> mRoot;    // 根结点<br>    // 构造函数<br>    public AVLTree() {<br>        mRoot = null;<br>    }<br>    /*<br>     * 获取树的高度<br>     <em>/<br>    private int height(AVLTreeNode<T> tree) {<br>        if (tree != null)<br>            return tree.height;<br>        return 0;<br>    }<br>    public int height() {<br>        return height(mRoot);<br>    }<br>    /</em><br>     * 比较两个值的大小<br>     <em>/<br>    private int max(int a, int b) {<br>        return a&gt;b ? a : b;<br>    }<br>    /</em><br>     * 前序遍历”AVL树”<br>     <em>/<br>    private void preOrder(AVLTreeNode<T> tree) {<br>        if(tree != null) {<br>            System.out.print(tree.key+” “);<br>            preOrder(tree.left);<br>            preOrder(tree.right);<br>        }<br>    }<br>    public void preOrder() {<br>        preOrder(mRoot);<br>    }<br>    /</em><br>     * 中序遍历”AVL树”<br>     <em>/<br>    private void inOrder(AVLTreeNode<T> tree) {<br>        if(tree != null) {<br>            inOrder(tree.left);<br>            System.out.print(tree.key+” “);<br>            inOrder(tree.right);<br>        }<br>    }<br>    public void inOrder() {<br>        inOrder(mRoot);<br>    }<br>    /</em><br>     * 后序遍历”AVL树”<br>     <em>/<br>    private void postOrder(AVLTreeNode<T> tree) {<br>        if(tree != null) {<br>            postOrder(tree.left);<br>            postOrder(tree.right);<br>            System.out.print(tree.key+” “);<br>        }<br>    }<br>    public void postOrder() {<br>        postOrder(mRoot);<br>    }<br>    /</em><br>     * (递归实现)查找”AVL树x”中键值为key的节点<br>     <em>/<br>    private AVLTreeNode<T> search(AVLTreeNode<T> x, T key) {<br>        if (x==null)<br>            return x;<br>        int cmp = key.compareTo(x.key);<br>        if (cmp &lt; 0)<br>            return search(x.left, key);<br>        else if (cmp &gt; 0)<br>            return search(x.right, key);<br>        else<br>            return x;<br>    }<br>    public AVLTreeNode<T> search(T key) {<br>        return search(mRoot, key);<br>    }<br>    /</em><br>     * (非递归实现)查找”AVL树x”中键值为key的节点<br>     <em>/<br>    private AVLTreeNode<T> iterativeSearch(AVLTreeNode<T> x, T key) {<br>        while (x!=null) {<br>            int cmp = key.compareTo(x.key);<br>            if (cmp &lt; 0)<br>                x = x.left;<br>            else if (cmp &gt; 0)<br>                x = x.right;<br>            else<br>                return x;<br>        }<br>        return x;<br>    }<br>    public AVLTreeNode<T> iterativeSearch(T key) {<br>        return iterativeSearch(mRoot, key);<br>    }<br>    /</em><br>     * 查找最小结点：返回tree为根结点的AVL树的最小结点。<br>     <em>/<br>    private AVLTreeNode<T> minimum(AVLTreeNode<T> tree) {<br>        if (tree == null)<br>            return null;<br>        while(tree.left != null)<br>            tree = tree.left;<br>        return tree;<br>    }<br>    public T minimum() {<br>        AVLTreeNode<T> p = minimum(mRoot);<br>        if (p != null)<br>            return p.key;<br>        return null;<br>    }<br>    /</em><br>     * 查找最大结点：返回tree为根结点的AVL树的最大结点。<br>     <em>/<br>    private AVLTreeNode<T> maximum(AVLTreeNode<T> tree) {<br>        if (tree == null)<br>            return null;<br>        while(tree.right != null)<br>            tree = tree.right;<br>        return tree;<br>    }<br>    public T maximum() {<br>        AVLTreeNode<T> p = maximum(mRoot);<br>        if (p != null)<br>            return p.key;<br>        return null;<br>    }<br>    /</em><br>     * LL：左左对应的情况(左单旋转)。<br>     * 返回值：旋转后的根节点<br>     <em>/<br>    private AVLTreeNode<T> leftLeftRotation(AVLTreeNode<T> k2) {<br>        AVLTreeNode<T> k1;<br>        k1 = k2.left;<br>        k2.left = k1.right;<br>        k1.right = k2;<br>        k2.height = max( height(k2.left), height(k2.right)) + 1;<br>        k1.height = max( height(k1.left), k2.height) + 1;<br>        return k1;<br>    }<br>    /</em><br>     * RR：右右对应的情况(右单旋转)。<br>     *<br>     * 返回值：旋转后的根节点<br>     <em>/<br>    private AVLTreeNode<T> rightRightRotation(AVLTreeNode<T> k1) {<br>        AVLTreeNode<T> k2;<br>        k2 = k1.right;<br>        k1.right = k2.left;<br>        k2.left = k1;<br>        k1.height = max( height(k1.left), height(k1.right)) + 1;<br>        k2.height = max( height(k2.right), k1.height) + 1;<br>        return k2;<br>    }<br>    /</em><br>     * LR：左右对应的情况(左双旋转)。<br>     * 返回值：旋转后的根节点<br>     <em>/<br>    private AVLTreeNode<T> leftRightRotation(AVLTreeNode<T> k3) {<br>        k3.left = rightRightRotation(k3.left);<br>        return leftLeftRotation(k3);<br>    }<br>    /</em><br>     * RL：右左对应的情况(右双旋转)。<br>     * 返回值：旋转后的根节点<br>     <em>/<br>    private AVLTreeNode<T> rightLeftRotation(AVLTreeNode<T> k1) {<br>        k1.right = leftLeftRotation(k1.right);<br>        return rightRightRotation(k1);<br>    }<br>    /</em><br>     * 将结点插入到AVL树中，并返回根节点<br>     * 参数说明：<br>     *     tree AVL树的根结点<br>     *     key 插入的结点的键值<br>     * 返回值：<br>     *     根节点<br>     <em>/<br>    private AVLTreeNode<T> insert(AVLTreeNode<T> tree, T key) {<br>        if (tree == null) {<br>            // 新建节点<br>            tree = new AVLTreeNode<T>(key, null, null);<br>            if (tree==null) {<br>                System.out.println(“ERROR: create avltree node failed!”);<br>                return null;<br>            }<br>        } else {<br>            int cmp = key.compareTo(tree.key);<br>            if (cmp &lt; 0) {    // 应该将key插入到”tree的左子树”的情况<br>                tree.left = insert(tree.left, key);<br>                // 插入节点后，若AVL树失去平衡，则进行相应的调节。<br>                if (height(tree.left) - height(tree.right) == 2) {<br>                    if (key.compareTo(tree.left.key) &lt; 0)<br>                        tree = leftLeftRotation(tree);<br>                    else<br>                        tree = leftRightRotation(tree);<br>                }<br>            } else if (cmp &gt; 0) {    // 应该将key插入到”tree的右子树”的情况<br>                tree.right = insert(tree.right, key);<br>                // 插入节点后，若AVL树失去平衡，则进行相应的调节。<br>                if (height(tree.right) - height(tree.left) == 2) {<br>                    if (key.compareTo(tree.right.key) &gt; 0)<br>                        tree = rightRightRotation(tree);<br>                    else<br>                        tree = rightLeftRotation(tree);<br>                }<br>            } else {    // cmp==0<br>                System.out.println(“添加失败：不允许添加相同的节点！”);<br>            }<br>        }<br>        tree.height = max( height(tree.left), height(tree.right)) + 1;<br>        return tree;<br>    }<br>    public void insert(T key) {<br>        mRoot = insert(mRoot, key);<br>    }<br>    /</em><br>     * 删除结点(z)，返回根节点<br>     * 参数说明：<br>     *     tree AVL树的根结点<br>     *     z 待删除的结点<br>     * 返回值：<br>     *     根节点<br>     <em>/<br>    private AVLTreeNode<T> remove(AVLTreeNode<T> tree, AVLTreeNode<T> z) {<br>        // 根为空 或者 没有要删除的节点，直接返回null。<br>        if (tree==null || z==null)<br>            return null;<br>        int cmp = z.key.compareTo(tree.key);<br>        if (cmp &lt; 0) {        // 待删除的节点在”tree的左子树”中<br>            tree.left = remove(tree.left, z);<br>            // 删除节点后，若AVL树失去平衡，则进行相应的调节。<br>            if (height(tree.right) - height(tree.left) == 2) {<br>                AVLTreeNode<T> r =  tree.right;<br>                if (height(r.left) &gt; height(r.right))<br>                    tree = rightLeftRotation(tree);<br>                else<br>                    tree = rightRightRotation(tree);<br>            }<br>        } else if (cmp &gt; 0) {    // 待删除的节点在”tree的右子树”中<br>            tree.right = remove(tree.right, z);<br>            // 删除节点后，若AVL树失去平衡，则进行相应的调节。<br>            if (height(tree.left) - height(tree.right) == 2) {<br>                AVLTreeNode<T> l =  tree.left;<br>                if (height(l.right) &gt; height(l.left))<br>                    tree = leftRightRotation(tree);<br>                else<br>                    tree = leftLeftRotation(tree);<br>            }<br>        } else {    // tree是对应要删除的节点。<br>            // tree的左右孩子都非空<br>            if ((tree.left!=null) &amp;&amp; (tree.right!=null)) {<br>                if (height(tree.left) &gt; height(tree.right)) {<br>                    // 如果tree的左子树比右子树高；<br>                    // 则(01)找出tree的左子树中的最大节点<br>                    //   (02)将该最大节点的值赋值给tree。<br>                    //   (03)删除该最大节点。<br>                    // 这类似于用”tree的左子树中最大节点”做”tree”的替身；<br>                    // 采用这种方式的好处是：删除”tree的左子树中最大节点”之后，AVL树仍然是平衡的。<br>                    AVLTreeNode<T> max = maximum(tree.left);<br>                    tree.key = max.key;<br>                    tree.left = remove(tree.left, max);<br>                } else {<br>                    // 如果tree的左子树不比右子树高(即它们相等，或右子树比左子树高1)<br>                    // 则(01)找出tree的右子树中的最小节点<br>                    //   (02)将该最小节点的值赋值给tree。<br>                    //   (03)删除该最小节点。<br>                    // 这类似于用”tree的右子树中最小节点”做”tree”的替身；<br>                    // 采用这种方式的好处是：删除”tree的右子树中最小节点”之后，AVL树仍然是平衡的。<br>                    AVLTreeNode<T> min = maximum(tree.right);<br>                    tree.key = min.key;<br>                    tree.right = remove(tree.right, min);<br>                }<br>            } else {<br>                AVLTreeNode<T> tmp = tree;<br>                tree = (tree.left!=null) ? tree.left : tree.right;<br>                tmp = null;<br>            }<br>        }<br>        return tree;<br>    }<br>    public void remove(T key) {<br>        AVLTreeNode<T> z;<br>        if ((z = search(mRoot, key)) != null)<br>            mRoot = remove(mRoot, z);<br>    }<br>    /</em><br>     * 销毁AVL树<br>     <em>/<br>    private void destroy(AVLTreeNode<T> tree) {<br>        if (tree==null)<br>            return ;<br>        if (tree.left != null)<br>            destroy(tree.left);<br>        if (tree.right != null)<br>            destroy(tree.right);<br>        tree = null;<br>    }<br>    public void destroy() {<br>        destroy(mRoot);<br>    }<br>    /</em><br>     * 打印”二叉查找树”<br>     * key        – 节点的键值<br>     * direction  –  0，表示该节点是根节点;<br>     *               -1，表示该节点是它的父结点的左孩子;<br>     *                1，表示该节点是它的父结点的右孩子。<br>     */<br>    private void print(AVLTreeNode<T> tree, T key, int direction) {<br>        if(tree != null) {<br>            if(direction==0)    // tree是根节点<br>                System.out.printf(“%2d is root\n”, tree.key, key);<br>            else                // tree是分支节点<br>                System.out.printf(“%2d is %2d’s %6s child\n”, tree.key, key, direction==1?”right” : “left”);<br>            print(tree.left, tree.key, -1);<br>            print(tree.right,tree.key,  1);<br>        }<br>    }<br>    public void print() {<br>        if (mRoot != null)<br>            print(mRoot, mRoot.key, 0);<br>    }<br>} </p>
<p>class BinaryTreeClass {<br>    int size = 0;<br>    MyNode rootNode;<br>    public BinaryTreeClass() {<br>        rootNode = null;<br>    }<br>    // 插入数据<br>    public void insert(int value) {<br>        if (rootNode == null) {<br>            rootNode = new MyNode(null,value,null);<br>            size ++;<br>        }else{<br>            MyNode currNode = rootNode;<br>            while (currNode != null) {<br>                if (value &lt; currNode.data) {<br>                    if (currNode.leftNode == null) {<br>                        currNode.leftNode = new MyNode(null,value,null);<br>                        size ++;<br>                        break;<br>                    } else {<br>                        currNode = currNode.leftNode;<br>                    }<br>                } else {<br>                    if (currNode.rightNode == null) {<br>                        currNode.rightNode = new MyNode(null,value,null);<br>                        size ++;<br>                        break;<br>                    } else {<br>                        currNode = currNode.rightNode;<br>                    }<br>                }<br>            }<br>        }<br>    }<br>    //按关键字查找节点<br>    public MyNode find(int key){<br>        MyNode cur = rootNode;  //从根节点开始查找<br>        if(cur == null){  //如果树为空，直接返回null<br>          return null;<br>        }<br>        while(cur.data != key){<br>            if(key &lt; cur.data){<br>                cur = cur.leftNode;  //如果关键字比当前节点小，转向左子节点<br>            }else {<br>                cur = cur.rightNode;  //如果关键字比当前节点大，转向右子节点<br>            }<br>            if(cur == null){  //没有找到结果，搜索结束<br>               return null;<br>            }<br>        }<br>        return cur;<br>    }<br>    public void printValue(MyNode node) {<br>        System.out.println(“====” + node.data + “==”);<br>    }<br>    // 前序遍历<br>    public void prevTraversal(MyNode tmpNode) {<br>        if (tmpNode != null) {<br>            this.printValue(tmpNode);<br>            prevTraversal(tmpNode.leftNode);<br>            prevTraversal(tmpNode.rightNode);<br>        }<br>    }<br>    // 中序遍历<br>    public void midTraversal(MyNode tmpNode) {<br>        if (tmpNode != null) {<br>            midTraversal(tmpNode.leftNode);<br>            this.printValue(tmpNode);<br>            midTraversal(tmpNode.rightNode);<br>        }<br>    }<br>    // 后序遍历<br>    public void reatTraversal(MyNode tmpNode) {<br>        if (tmpNode != null) {<br>            reatTraversal(tmpNode.leftNode);<br>            reatTraversal(tmpNode.rightNode);<br>            this.printValue(tmpNode);<br>        }<br>    }<br>    public boolean delete(int value) {<br>        boolean isLeftNode = false;<br>        MyNode parentNode = null;<br>        MyNode currNode = rootNode;<br>//<br>        while (currNode.data != value) {<br>            parentNode = currNode;<br>            if (value &lt; currNode.data) {<br>                isLeftNode = true;<br>                currNode = currNode.leftNode;<br>            } else {<br>                isLeftNode = false;<br>                currNode = currNode.rightNode;<br>            }<br>            if (currNode == null) { // 没找到这个值<br>                return false;<br>            }<br>        }<br>        if (currNode.leftNode == null &amp;&amp; currNode.rightNode == null) {<br>            if (currNode == rootNode) {<br>                rootNode = null;<br>            } else if (isLeftNode == true) {<br>                parentNode.leftNode = null;<br>            } else {<br>                parentNode.rightNode = null;<br>            }<br>            size –;<br>            return true;<br>        } else if (currNode.leftNode != null &amp;&amp; currNode.rightNode == null) {<br>            if (currNode == rootNode) {<br>                rootNode = currNode.leftNode;<br>            } else if (isLeftNode == true) {<br>                parentNode.leftNode = currNode.leftNode;<br>            } else {<br>                parentNode.rightNode = currNode.leftNode;<br>            }<br>            size –;<br>            return true;<br>        } else if (currNode.leftNode == null &amp;&amp; currNode.rightNode != null) {<br>            if (currNode == rootNode) {<br>                rootNode = currNode.rightNode;<br>            } else if (isLeftNode = true) {<br>                parentNode.leftNode = currNode.rightNode;<br>            } else {<br>                parentNode.rightNode = currNode.rightNode;<br>            }<br>            size –;<br>            return true;<br>        }else {<br>              //第一步要找到欲删除节点的后继节点<br>              MyNode successor = currNode.rightNode;<br>              MyNode successorParent = null;<br>              while(successor.leftNode != null){<br>                  successorParent = successor;<br>                  successor = successor.leftNode;<br>              }<br>              //欲删除节点的右子节点就是它的后继，证明该后继无左子节点，则将以后继节点为根的子树上移即可<br>              if(successorParent == null){<br>                  if(currNode == rootNode){  //要删除的为根节点，则将后继设置为根，且根的左子节点设置为欲删除节点的做左子节点<br>                      rootNode = successor;<br>                      rootNode.leftNode = currNode.leftNode;<br>                  }else if(isLeftNode == true){<br>                      parentNode.leftNode = successor;<br>                      successor.leftNode = currNode.leftNode;<br>                  }else{<br>                      parentNode.rightNode = successor;<br>                      successor.leftNode = currNode.leftNode;<br>                  }<br>              }else{ //欲删除节点的后继不是它的右子节点<br>                  successorParent.leftNode = successor.rightNode;<br>                  successor.rightNode = currNode.rightNode;<br>                  if(currNode == rootNode){<br>                      rootNode = successor;<br>                      rootNode.leftNode = currNode.leftNode;<br>                  }else if(isLeftNode == true){<br>                      parentNode.leftNode = successor;<br>                      successor.leftNode = currNode.leftNode;<br>                  }else{<br>                      parentNode.rightNode = successor;<br>                      successor.leftNode = currNode.leftNode;<br>                  }<br>              }<br>        }<br>        return false;<br>    }<br>    //私有方法，用迭代方法来获取左子树和右子树的最大深度，返回两者最大值<br>    private int getDepth(MyNode currentNode,int initDeep){<br>        int deep = initDeep;  //当前节点已到达的深度<br>        int leftDeep = initDeep;<br>        int rightDeep = initDeep;<br>        if(currentNode.leftNode != null){  //计算当前节点左子树的最大深度<br>            leftDeep = getDepth(currentNode.leftNode, deep+1);<br>        }<br>        if(currentNode.rightNode != null){  //计算当前节点右子树的最大深度<br>            rightDeep = getDepth(currentNode.rightNode, deep+1);<br>        }<br>        return Math.max(leftDeep, rightDeep);<br>    }<br>    //获取树的深度<br>    public int getTreeDepth() {<br>        if (rootNode == null) {<br>            return 0;<br>        }<br>        return getDepth(rootNode, 1);<br>    }<br>    //以树的形式打印出该树<br>    public void displayTree(){<br>        int depth = getTreeDepth();<br>        ArrayList<MyNode> currentLayerNodes = new ArrayList<MyNode> ();<br>        currentLayerNodes.add(rootNode);  //存储该层所有节点<br>        int layerIndex = 1;<br>        while(layerIndex &lt;= depth){<br>            int NodeBlankNum = (int)Math.pow(2, depth-layerIndex)-1;  //在节点之前和之后应该打印几个空位<br>            for(int i = 0;i&lt;currentLayerNodes.size();i++){<br>                MyNode node = currentLayerNodes.get(i);<br>                if(node == null){<br>                    System.out.print(“*\t”);  //如果该节点为null，用空位代替<br>                }else{<br>                    System.out.print(“*  “+node.data+”\t”);  //打印该节点<br>                }<br>                System.out.print(“*\t”);   //补齐空位<br>            }<br>            System.out.println();<br>            layerIndex++;<br>            currentLayerNodes = getAllNodeOfThisLayer(currentLayerNodes);  //获取下一层所有的节点<br>        }<br>    }<br>    //获取指定节点集合的所有子节点<br>    private ArrayList getAllNodeOfThisLayer(List parentNodes){<br>        ArrayList list = new ArrayList<MyNode>();<br>        MyNode parentNode;<br>        for(int i=0;i&lt;parentNodes.size();i++){<br>            parentNode = (MyNode)parentNodes.get(i);<br>            if(parentNode != null){<br>                if(parentNode.leftNode != null){  //如果上层的父节点存在左子节点，加入集合<br>                  list.add(parentNode.leftNode);<br>                }else{<br>                    list.add(null);  //如果上层的父节点不存在左子节点，用null代替，一样加入集合<br>                }<br>                if(parentNode.rightNode != null){<br>                    list.add(parentNode.rightNode);<br>                }else{<br>                    list.add(null);<br>                }<br>            }else{  //如果上层父节点不存在，用两个null占位，代表左右子节点<br>                list.add(null);<br>                list.add(null);<br>            }<br>        }<br>        return list;<br>    }<br>}<br>class MyNode {<br>    public int data;<br>    public MyNode leftNode;<br>    public MyNode rightNode;<br>    public MyNode(int d) {<br>        this(null,d,null);<br>    }<br>    public MyNode(MyNode leftN,int d,MyNode rightN) {<br>        this.leftNode = leftN;<br>        this.data = d;<br>        this.rightNode = rightN;<br>    }<br>    public void printNode() {<br>        System.out.println(“==” + this.data + “==”);<br>    }<br>}</p>
<p>class BinaryTree {<br>    public TreeNode createTree() {<br>        TreeNode<String> nodeH = new TreeNode&lt;&gt;(“H”);<br>        TreeNode<String> nodeG = new TreeNode&lt;&gt;(“G”);<br>//<br>        TreeNode<String> nodeF = new TreeNode&lt;&gt;(nodeH, “F”, null);<br>        TreeNode<String> nodeE = new TreeNode&lt;&gt;(nodeG, “E”, null);<br>        TreeNode<String> nodeD = new TreeNode&lt;&gt;(“D”);<br>//<br>        TreeNode<String> nodeC = new TreeNode&lt;&gt;(null, “C”, nodeF);<br>        TreeNode<String> nodeB = new TreeNode&lt;&gt;(nodeD, “B”, nodeE);<br>        TreeNode<String> nodeA = new TreeNode&lt;&gt;(nodeB, “A”, nodeC);<br>        return nodeA;<br>    }<br>    // 访问每个结点<br>    private void visitNode(TreeNode node) {<br>        //System.out.print(“  “ + node.getData().toString() + “  “);<br>        System.out.println(“  “ + node.getData() + “  “);<br>    }<br>    //前序遍历-递归实现<br>    void preTraversal(TreeNode node) {<br>        if (node != null) {<br>            visitNode(node);<br>            preTraversal(node.getLeftChild());<br>            preTraversal(node.getRightChild());<br>        }<br>    }<br>    //中序遍历-递归实现<br>    void traversal(TreeNode node) {<br>        if (node != null) {<br>            traversal(node.getLeftChild());<br>            visitNode(node);<br>            traversal(node.getRightChild());<br>        }<br>    }<br>    //后序遍历-递归实现<br>    void postTraversal(TreeNode node) {<br>        if (node != null) {<br>            postTraversal(node.getLeftChild());<br>            postTraversal(node.getRightChild());<br>            visitNode(node);<br>        }<br>    }<br>    // 前序遍历-迭代实现<br>    void preTraversalIteration(TreeNode node) {<br>        // 创建一个栈<br>        Stack<TreeNode> mStack = new Stack&lt;&gt;();<br>        while (true) {<br>            while (node != null) { // 非叶子结点的子树<br>                // 前序遍历，先访问根结点<br>                visitNode(node);<br>                // 将当前结点压入栈<br>                mStack.push(node);<br>                // 对左子树继续进行前序遍历<br>                node=node.getLeftChild();<br>            }<br>            if (mStack.isEmpty()) {<br>                //所有元素已遍历完成<br>                break;<br>            }<br>            // 弹出栈顶结点<br>            node=mStack.pop();<br>            // 右子树前序遍历<br>            node=node.getRightChild();<br>        }<br>    }<br>    //中序遍历-迭代实现<br>    void TraversalIteration(TreeNode node) {<br>        // 创建一个栈<br>        Stack<TreeNode> mStack = new Stack&lt;&gt;();<br>        while (true) {<br>            while (node != null) { // 非叶子结点的子树<br>                // 将当前结点压入栈<br>                mStack.push(node);<br>                // 对左子树继续进行中序遍历<br>                node=node.getLeftChild();<br>            }<br>            if (mStack.isEmpty()) {<br>                //所有元素已遍历完成<br>                break;<br>            }<br>            // 弹出栈顶结点<br>            node=mStack.pop();<br>            // 中序遍历，访问根结点<br>            visitNode(node);<br>            // 右子树中序遍历<br>            node=node.getRightChild();<br>        }<br>    }<br>    //后序遍历-迭代实现<br>    void postTraversalIteration(TreeNode node) {<br>        // 创建一个栈<br>        Stack<TreeNode> mStack = new Stack&lt;&gt;();<br>        while (true) {<br>            if (node != null) {<br>                //当前结点非空，压入栈<br>                mStack.push(node);<br>                // 左子树继续遍历<br>                node=node.getLeftChild();<br>            }else {<br>                // 左子树为空<br>                if(mStack.isEmpty()){<br>                    return;<br>                }<br>                if (mStack.lastElement().getRightChild() == null) {<br>                    // 栈顶元素右子树为空，则当前结点为叶子结点，输出<br>                    node=mStack.pop();<br>                    visitNode(node);<br>                    while (node == mStack.lastElement().getRightChild()) {<br>                        visitNode(mStack.lastElement());<br>                        node=mStack.pop();<br>                        if (mStack.isEmpty()) {<br>                            break;<br>                        }<br>                    }<br>                }<br>                if (!mStack.isEmpty()) {<br>                    node=mStack.lastElement().getRightChild();<br>                }else {<br>                    node=null;<br>                }<br>            }<br>        }<br>    }<br>    //层序遍历<br>    void levelTraversal(TreeNode node) {<br>        //创建队列<br>        Queue<TreeNode> mNodeQueue = new LinkedList&lt;&gt;();<br>        // 根结点加入队列<br>        mNodeQueue.add(node);<br>        TreeNode temp;<br>        while (!mNodeQueue.isEmpty()) {<br>            System.out.print(“========size=======  “ + mNodeQueue.size());<br>            //元素出队列<br>            temp=mNodeQueue.poll();<br>            //输出<br>            visitNode(temp);<br>            if (temp.getLeftChild() != null) {<br>                // 左子树入队列<br>                mNodeQueue.add(temp.getLeftChild());<br>                System.out.println(“========getLeftChild =======  “ + temp.getLeftChild().getData());<br>            }<br>            if (temp.getRightChild() != null) {<br>                //右子树入队列<br>                mNodeQueue.add(temp.getRightChild());<br>                System.out.println(“========getRightChild=======  “ + temp.getRightChild().getData());<br>            }<br>        }<br>    }<br>}<br>class TreeNode<T> {<br>    private T data;<br>    private TreeNode<T> leftChild;<br>    private TreeNode<T> rightChild;<br>//<br>    public TreeNode(T data) {<br>        this(null, data, null);<br>    }<br>    public TreeNode(TreeNode<T> leftChild, T data, TreeNode<T> rightChild) {<br>        this.leftChild = leftChild;<br>        this.data = data;<br>        this.rightChild = rightChild;<br>    }<br>    public T getData() {<br>        return data;<br>    }<br>    public TreeNode<T> getLeftChild() {<br>        return leftChild;<br>    }<br>    public TreeNode<T> getRightChild() {<br>        return rightChild;<br>    }<br>}</p> </div>
</article>

    </main>

    <footer id="layout_footer">
        
<div id="footer_background">
    <div id="footer_copyright">© Created by linyafei | 2020.</div>
    <div id="footer_copyright">Powered by Hexo | theme Sanjiantang</div>
</div>

    </footer>
</body>
</html>

